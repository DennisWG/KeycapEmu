## if attrib/type == "string"
{##}
            auto size_{{ attrib/name }} = decoder.get<uint8>();
            packet.{{attrib/name}} = decoder.get_string(size_{{ attrib/name }});
## if hasAnnotation(attrib, "expects")
{##}
            ensure("{{attrib/name}}", packet.{{attrib/name}}, "{{annotationValue(attrib, "expects")}}");
## endif
## else if attrib/hasSpecifier
## if hasSpecifier(attrib, "repeated")
{##}
            auto size_{{attrib/name}} = decoder.get<uint8>();
            for (int i = 0; i < size_{{attrib/name}}; ++i)
                packet.{{attrib/name}}.push_back(decoder.get<{{ attrib/type }}>());
## else if hasSpecifier(attrib, "optional")
{##}
            if (decoder.size() >= sizeof({{ attrib/type }}))

## if isUserDefinedData(attrib/type)
                packet.{{attrib/name}} = {{ attrib/type }}::decode(decoder);
## else
                packet.{{attrib/name}} = decoder.get<{{ attrib/type }}>();
## endif
## endif
## else if attrib/hasArraySize
{##}
            packet.{{attrib/name}} = decoder.get<{{ attrib/type }}, {{ attrib/arraySize }}>();
## else if not hasAnnotation(attrib, "is_size")
{##}
            packet.{{attrib/name}} = decoder.get<{{ attrib/type }}>();
## endif
## if hasAnnotation(attrib, "expects")
{##}
            ensure("{{attrib/name}}", packet.{{attrib/name}}, {{annotationValue(attrib, "expects")}});

## else if hasAnnotation(attrib, "reverse")
{##}
            std::reverse(std::begin(packet.{{attrib/name}}), std::end(packet.{{attrib/name}}));

## endif