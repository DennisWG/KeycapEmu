/*
    Copyright 2018 KeycapEmu

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

// This file was generated. DO NOT EDIT!

#pragma once

#include <Keycap/Root/Utility/Enum.hpp>
#include <Keycap/Root/Network/MemoryStream.hpp>
#include <Keycap/Root/Types.hpp>
#include <Keycap/Root/Utility/Utility.hpp>
## if hasImports
## for imp in imports
#include "{{ imp/importName }}.hpp"

## endfor
{##}

## endif
{##}

namespace {% for i in modulePath %}{% if is_first %}{{ i }}{% else %}::{{ i }}{% endif %}{% endfor %}
{
## if hasEnums
## for enum in enums
{##}
    keycap_enum({{ enum/name }}, {% if enum/alignment == "byte" %}uint8{% else if enum/alignment == "word" %}uint16{% else if enum/alignment == "dword" %}uint32{% else if enum/alignment == "qword" %}uint64{% endif %},{%
for value in enum/values %}
        {{ value/name }} = {{ value/value }},{%
endfor %}
    );

## endfor
## endif
{##}
#pragma pack(push, 1)

## if hasData
## for dat in data
{##}
    struct {{ dat/name }}
    {
    public:{%
for attrib in dat/attributes %}
        {% if attrib/hasArraySize %}std::array<{% endif %}{% if attrib/hasSpecifier %}{% if attrib/specifier == "optional" %}boost::optional<{% else %}std::vector<{% endif %}{% endif %}{{ attrib/type }}{% if attrib/hasSpecifier %}>{% endif %}{% if attrib/hasArraySize %}, {{ attrib/arraySize }}>{% endif %} {{ attrib/name }};{%
endfor %}

        void Encode(Keycap::Root::Network::MemoryStream& encoder)
        {
## for attrib in dat/attributes
## if attrib/type == "string"
{##}
            encoder.Put(static_cast<uint8>({{attrib/name}}.size()));
            encoder.Put({{attrib/name}});
## else if attrib/hasSpecifier
## if attrib/specifier == "repeated"
{##}
            encoder.Put(static_cast<uint8>({{attrib/name}}.size()));
            encoder.Put({{attrib/name}});
## endif
## else
{##}
            encoder.Put({{attrib/name}});
## endif
## endfor
{##}
        }

        static {{ dat/name }} Decode(Keycap::Root::Network::MemoryStream& decoder)
        {
            {{ dat/name }} packet;
## for attrib in dat/attributes
## if attrib/type == "string"
{##}
            auto size_{{ attrib/name }} = decoder.Get<uint8>();
            packet.{{attrib/name}} = decoder.GetString(size_{{ attrib/name }});
## if attrib/hasAnnotations
## for annotation in attrib/annotations
## if annotation/name == "Expects"
{##}
            ensure("{{attrib/name}}", packet.{{attrib/name}}, "{{annotation/value}}");
## endif
## endfor
## endif
## else if attrib/hasSpecifier
## if attrib/specifier == "repeated"
{##}
            auto size_{{attrib/name}} = decoder.Get<uint8>();
            for(int i = 0; i < size_{{attrib/name}}; ++i)
                packet.{{attrib/name}}.push_back(decoder.Get<{{ attrib/type }}>());
## endif
## else if attrib/hasArraySize
{##}
            packet.{{attrib/name}} = decoder.Get<{{ attrib/type }}, {{ attrib/arraySize }}>();
## else
{##}
            packet.{{attrib/name}} = decoder.Get<{{ attrib/type }}>();
## if attrib/hasAnnotations
## for annotation in attrib/annotations
## if annotation/name == "Expects"
{##}
            ensure("{{attrib/name}}", packet.{{attrib/name}}, {{annotation/value}});
## endif
## endfor
## endif
## endif
## endfor
{##}
            return packet;
        }

    private:
        template <typename T1, typename T2>
        static void ensure(std::string const& name, T1 const& v1, T2 const& v2)
        {
            if(v1 != v2)
                throw std::exception(("Attribute '" + name + "'(" + std::to_string(v1) + ") was expected to be " + std::to_string(v2)).c_str());
        }

        template <typename T>
        static void ensure(std::string const& name, std::vector<T> const& v1,  std::vector<T> const& v2)
        {
            
        }
    };

## endfor
## endif
## if hasMessages
{##}
## for msg in messages
{##}
    class {{ msg/name }} final
    {
    public:{%
for attrib in msg/attributes %}
        {% if attrib/hasArraySize %}std::array<{% endif %}{% if attrib/hasSpecifier %}{% if attrib/specifier == "optional" %}boost::optional<{% else %}std::vector<{% endif %}{% endif %}{{ attrib/type }}{% if attrib/hasSpecifier %}>{% endif %}{% if attrib/hasArraySize %}, {{ attrib/arraySize }}>{% endif %} {{ attrib/name }};{%
endfor %}

        void Encode(Keycap::Root::Network::MemoryStream& encoder)
        {
## for attrib in msg/attributes
## if attrib/type == "string"
{##}
            encoder.Put(static_cast<uint8>({{attrib/name}}.size()));
            encoder.Put({{attrib/name}});
## else if attrib/hasSpecifier
## if attrib/specifier == "repeated"
{##}
            encoder.Put(static_cast<uint8>({{attrib/name}}.size()));
            encoder.Put({{attrib/name}});
## endif
## else
{##}
            encoder.Put({{attrib/name}});
## endif
## endfor
{##}
        }

        static {{ msg/name }} Decode(Keycap::Root::Network::MemoryStream& decoder)
        {
            {{ msg/name }} packet;
## for attrib in msg/attributes
## if attrib/type == "string"
{##}
            auto size_{{ attrib/name }} = decoder.Get<uint8>();
            packet.{{attrib/name}} = decoder.GetString(size_{{ attrib/name }});
## if attrib/hasAnnotations
## for annotation in attrib/annotations
## if annotation/name == "Expects"
{##}
            ensure("{{attrib/name}}", packet.{{attrib/name}}, "{{annotation/value}}");
## endif
## endfor
## endif
## else if attrib/hasSpecifier
## if attrib/specifier == "repeated"
{##}
            auto size_{{attrib/name}} = decoder.Get<uint8>();
            for(int i = 0; i < size_{{attrib/name}}; ++i)
                packet.{{attrib/name}}.push_back(decoder.Get<{{ attrib/type }}>());
## endif
## else if attrib/hasArraySize
{##}
            packet.{{attrib/name}} = decoder.Get<{{ attrib/type }}, {{ attrib/arraySize }}>();
## else
{##}
            packet.{{attrib/name}} = decoder.Get<{{ attrib/type }}>();
## if attrib/hasAnnotations
## for annotation in attrib/annotations
## if annotation/name == "Expects"
{##}
            ensure("{{attrib/name}}", packet.{{attrib/name}}, {{annotation/value}});
## endif
## endfor
## endif
## endif
## endfor
{##}
            return packet;
        }

        std::string ToString()
        {
            std::stringstream ss;
            ss << "Packet {{ msg/name }}\n";
## for attrib in msg/attributes
## if attrib/hasSpecifier
## if attrib/specifier == "optional"
{##}

            if({{ attrib/name }})
                ss << "    {{ attrib/name }} = " << *{{ attrib/name }};
            else
                ss << "    {{ attrib/name }} not set";
            ss << '\n';
## else
{##}

            ss << "    {{ attrib/name }}[" << {{ attrib/name }}.size() << "]\n";
            
            if constexpr(!std::is_class_v<{{ attrib/type }}>)
                Keycap::Root::Utility::DumpAsHex(std::begin({{ attrib/name }}), std::end({{ attrib/name }}), ss, 8);
## endif
## else if attrib/hasArraySize
{##}

            ss << "    {{ attrib/name }}[{{ attrib/arraySize }}]\n";
            if constexpr(!std::is_class_v<{{ attrib/type }}>)
                Keycap::Root::Utility::DumpAsHex(std::begin({{ attrib/name }}), std::end({{ attrib/name }}), ss, 8);
## else
{##}
            ss << "    {{ attrib/name }} = " << {{ attrib/name }} << '\n';
## endif
## endfor
{##}

            return ss.str();
        }

    private:
        template <typename T1, typename T2>
        static void ensure(std::string const& name, T1 const& v1, T2 const& v2)
        {
            if(v1 != v2)
                throw std::exception(("Attribute '" + name + "'(" + std::to_string(v1) + ") was expected to be " + std::to_string(v2)).c_str());
        }

        template <typename T>
        static void ensure(std::string const& name, std::vector<T> const& v1,  std::vector<T> const& v2)
        {
            
        }
    };

## endfor
## endif
{##}
#pragma pack(pop)
}