/*
    Copyright 2017 KeycapEmu

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

// This file was generated. DO NOT EDIT!

#include <Keycap/Root/Utility/Enum.hpp>
#include <Keycap/Root/Network/MemoryStream.hpp>
#include <Keycap/Root/Types.hpp>
## if hasImports
## for imp in imports
#include "{{ imp/importName }}.hpp"

## endfor
{##}

## endif
{##}

namespace {% for i in modulePath %}{% if is_first %}{{ i }}{% else %}::{{ i }}{% endif %}{% endfor %}
{
## if hasEnums
## for enum in enums
{##}
    keycap_enum({{ enum/name }}, {% if enum/alignment == "byte" %}uint8{% else if enum/alignment == "word" %}uint16{% else if enum/alignment == "dword" %}uint32{% else if enum/alignment == "qword" %}uint64{% endif %},{%
for value in enum/values %}
        {{ value/name }} = {{ value/value }},{%
endfor %}
    );

## endfor
## endif
{##}
#pragma pack(push, 1)

## if hasData
## for dat in data
{##}
    struct {{ dat/name }}
    {
    public:{%
for attrib in dat/attributes %}
        {% if attrib/hasSpecifier %}{% if attrib/specifier == "optional" %}boost::optional<{% else %}std::vector<{% endif %}{% endif %}{{ attrib/type }}{% if attrib/hasSpecifier %}>{% endif %} {{ attrib/name }};{%
endfor %}

        void encode(Keycap::Root::Network::MemoryStream& encoder)
        {
## for attrib in dat/attributes
## if attrib/type == "string"
{##}
            encoder.Put(static_cast<uint8>({{attrib/name}}.size()));
            encoder.Put({{attrib/name}});
## else
{##}
            encoder.Put({{attrib/name}});
## endif
## endfor
        }
    };

## endfor
## endif
## if hasMessages
{##}
## for msg in messages
{##}
    class {{ msg/name }} final
    {
    public:{%
for attrib in msg/attributes %}
        {% if attrib/hasArraySize %}std::array<{% endif %}{% if attrib/hasSpecifier %}{% if attrib/specifier == "optional" %}boost::optional<{% else %}std::vector<{% endif %}{% endif %}{{ attrib/type }}{% if attrib/hasSpecifier %}>{% endif %}{% if attrib/hasArraySize %}, {{ attrib/arraySize }}>{% endif %} {{ attrib/name }};{%
endfor %}

        void Encode(Keycap::Root::Network::MemoryStream& encoder)
        {
## for attrib in msg/attributes
## if attrib/type == "string"
{##}
            encoder.Put(static_cast<uint8>({{attrib/name}}.size()));
            encoder.Put({{attrib/name}});
## else
{##}
            encoder.Put({{attrib/name}});
## endif
## endfor
{##}
        }

        void Decode(Keycap::Root::Network::MemoryStream& decoder)
        {
## for attrib in msg/attributes
## if attrib/type == "string"
{##}
            auto size_{{ attrib/name }} = decoder.Get<uint8>();
            {{attrib/name}} = decoder.GetString(size_{{ attrib/name }});
## else if attrib/hasArraySize
{##}
            {{attrib/name}} = decoder.Get<{{ attrib/type }}, {{ attrib/arraySize }}>();
## else
{##}
            {{attrib/name}} = decoder.Get<{{ attrib/type }}>();
## endif
## endfor
{##}
        }

        std::string ToString()
        {
            std::stringstream ss;
            ss << "Packet {{ msg/name }}\n";
## for attrib in msg/attributes
## if attrib/hasSpecifier
## if attrib/specifier == "optional"
{##}

            if({{ attrib/name }})
                ss << "    {{ attrib/name }} = " << *{{ attrib/name }};
            else
                ss << "    {{ attrib/name }} not set";
            ss << '\n';
## else
{##}

            ss << "    {{ attrib/name }}[" << {{ attrib/name }}.size() << "\n        ";
            for(auto&& i_{{ attrib/name }} : {{ attrib/name }})
                ss << i_{{ attrib/name }} << ", ";
## endif
## else if attrib/hasArraySize
{##}

            ss << "    {{ attrib/name }}[{{ attrib/arraySize }}]\n        ";
            for(auto&& i_{{ attrib/name }} : {{ attrib/name }})
                ss << i_{{ attrib/name }} << ", ";
## else
{##}
            ss << "    " << {{ attrib/name }} << '\n';
## endif
## endfor
{##}

            return ss.str();
        }
    };

## endfor
## endif
{##}
#pragma pack(pop)
}