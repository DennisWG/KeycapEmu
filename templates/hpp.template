/*
    Copyright 2018 KeycapEmu

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

// This file was generated. DO NOT EDIT!

#pragma once

#include <keycap/root/utility/enum.hpp>
#include <keycap/root/network/memory_stream.hpp>
#include <keycap/root/types.hpp>
#include <keycap/root/utility/utility.hpp>

#include <boost/optional.hpp>

#include <spdlog/fmt/fmt.h>
## if hasImports
## for imp in imports
#include "{{ imp/importName }}.hpp"

## endfor
{##}

## endif
{##}

namespace {% for i in modulePath %}{% if loop/is_first %}{{ i }}{% else %}::{{ i }}{% endif %}{% endfor %}
{
## if hasEnums
## for enum in enums
{##}
    keycap_enum{% if hasAnnotation(enum, "Flags") %}_flags{% endif %}({{ enum/name }}, {% if enum/alignment == "byte" %}uint8{% else if enum/alignment == "word" %}uint16{% else if enum/alignment == "dword" %}uint32{% else if enum/alignment == "qword" %}uint64{% endif %},{%
for value in enum/values %}
        {{ value/name }} = {{ value/value }},{%
endfor %}
    );

## endfor
## endif
{##}
#pragma pack(push, 1)

## if hasData
## for dat in data
{##}
    struct {{ dat/name }}
    {
    public:{%
for attrib in dat/attributes %}
## if not hasAnnotation(attrib, "IsSize")

        {% if attrib/hasArraySize %}std::array<{% endif %}{% if attrib/hasSpecifier %}{% if attrib/specifier == "optional" %}boost::optional<{% else %}std::vector<{% endif %}{% endif %}{{ attrib/type }}{% if attrib/hasSpecifier %}>{% endif %}{% if attrib/hasArraySize %}, {{ attrib/arraySize }}>{% endif %} {{ attrib/name }}{% if attrib/hasDefaultValue %} = {{ attrib/defaultValue }}{% endif %};
## endif
{% endfor %}

## if hasAnnotation(dat, "ExpectedSize")
        static constexpr size_t expected_size = {{annotationValue(dat, "ExpectedSize")}};
## endif

        void encode(keycap::root::network::memory_stream& encoder)
        {
## for attrib in dat/attributes
## if attrib/type == "string"
## if hasAnnotation(attrib, "ZeroTeminated")
{##}
            encoder.put({{ attrib/name }});
            encoder.put<uint8>(0);
## else
{##}
            encoder.put(static_cast<uint8>({{ attrib/name }}.size()));
            encoder.put({{ attrib/name }});
## endif 
## else if attrib/hasSpecifier
## if hasSpecifier(attrib, "repeated")
{##}
            encoder.put(static_cast<{% if hasAnnotation(attrib, "SizeType") %}{{annotationValue(attrib, "SizeType")}}{% else %}uint8{% endif %}>({{attrib/name}}.size()));
            for(auto&& elem : {{ attrib/name }})
                elem.encode(encoder);
## else if hasSpecifier(attrib, "optional")
{##}
            if({{ attrib/name }})
                encoder.put({{ attrib/name }});
## endif
## else
## if not hasAnnotation(attrib, "IsSize")
{##}
            encoder.put({{attrib/name}});
## else
{##}
            auto position_{{ attrib/name }} = static_cast<{{ attrib/type }}>(encoder.size());
            encoder.put<{{ attrib/type }}>(0);
## endif
## endif
## endfor
{##}
## for attrib in dat/attributes
## if hasAnnotation(attrib, "IsSize")
{##}

            encoder.override(std::max<{{ attrib/type }}>(0, static_cast<{{ attrib/type }}>(encoder.size() - sizeof({{ attrib/type }}) - 1)), position_{{ attrib/name }});
## endif
## endfor
{##}
        }

        static {{ dat/name }} decode(keycap::root::network::memory_stream& decoder)
        {
            {{ dat/name }} packet;
## for attrib in dat/attributes
## if attrib/type == "string"
{##}
            auto size_{{ attrib/name }} = decoder.get<uint8>();
            packet.{{attrib/name}} = decoder.get_string(size_{{ attrib/name }});
## if attrib/hasAnnotations
## for annotation in attrib/annotations
## if annotation/name == "Expects"
{##}
            ensure("{{attrib/name}}", packet.{{attrib/name}}, "{{annotation/value}}");
## endif
## endfor
## endif
## else if attrib/hasSpecifier
## if hasSpecifier(attrib, "repeated")
{##}
            auto size_{{attrib/name}} = decoder.get<uint8>();
            for(int i = 0; i < size_{{attrib/name}}; ++i)
                packet.{{attrib/name}}.push_back(decoder.get<{{ attrib/type }}>());
## else if hasSpecifier(attrib, "optional")
{##}
            if(decoder.size() >= sizeof({{ attrib/type }}))
                packet.{{attrib/name}} = decoder.get<{{ attrib/type }}>();
## endif
## else if attrib/hasArraySize
{##}
            packet.{{attrib/name}} = decoder.get<{{ attrib/type }}, {{ attrib/arraySize }}>();
## else if not hasAnnotation(attrib, "IsSize")
{##}
            packet.{{attrib/name}} = decoder.get<{{ attrib/type }}>();
## endif
## if attrib/hasAnnotations
## for annotation in attrib/annotations
## if annotation/name == "Expects"
{##}
            ensure("{{attrib/name}}", packet.{{attrib/name}}, {{annotation/value}});

## else if annotation/name == "Reverse"
{##}
            std::reverse(std::begin(packet.{{attrib/name}}), std::end(packet.{{attrib/name}}));

## endif
## endfor
## endif
## endfor
{##}
            return packet;
        }

    private:
        template <typename T1, typename T2>
        static void ensure(std::string const& name, T1 const& v1, T2 const& v2)
        {
            if(v1 != v2)
                throw std::exception(fmt::format("Attribute '{}'({}) was expected to be {}", name, std::to_string(v1), std::to_string(v2)).c_str());
        }

        template <typename T>
        static void ensure(std::string const& name, std::vector<T> const& v1,  std::vector<T> const& v2)
        {
            
        }
    };

## endfor
## endif
## if hasMessages
{##}
## for msg in messages
{##}
    class {{ msg/name }} final
    {
    public:{%
for attrib in msg/attributes %}
        {% if attrib/hasArraySize %}std::array<{% endif %}{% if attrib/hasSpecifier %}{% if attrib/specifier == "optional" %}boost::optional<{% else %}std::vector<{% endif %}{% endif %}{{ attrib/type }}{% if attrib/hasSpecifier %}>{% endif %}{% if attrib/hasArraySize %}, {{ attrib/arraySize }}>{% endif %} {{ attrib/name }}{% if attrib/hasDefaultValue %} = {{ attrib/defaultValue }}{% endif %};{%
endfor %}

## if hasAnnotation(msg, "ExpectedSize")

        static constexpr size_t expected_size = {{annotationValue(msg, "ExpectedSize")}};

## endif

        void encode(keycap::root::network::memory_stream& encoder)
        {
## for attrib in msg/attributes
## if attrib/type == "string"
## if hasAnnotation(attrib, "ZeroTeminated")
{##}
            encoder.put({{ attrib/name }});
            encoder.put<uint8>(0);
## else
{##}
            encoder.put(static_cast<uint8>({{ attrib/name }}.size()));
            encoder.put({{ attrib/name }});
## endif 
## else if attrib/hasSpecifier
## if hasSpecifier(attrib, "repeated")
{##}
            encoder.put(static_cast<{% if hasAnnotation(attrib, "SizeType") %}{{annotationValue(attrib, "SizeType")}}{% else %}uint8{% endif %}>({{attrib/name}}.size()));
            for(auto&& elem : {{ attrib/name }})
                elem.encode(encoder);
## else if hasSpecifier(attrib, "optional")
{##}
            if({{ attrib/name }})
                encoder.put({{ attrib/name }});
## endif
## else
## if not hasAnnotation(attrib, "IsSize")
{##}
            encoder.put({{attrib/name}});
## else
{##}
            auto position_{{ attrib/name }} = static_cast<{{ attrib/type }}>(encoder.size());
            encoder.put<{{ attrib/type }}>(0);
## endif
## endif
## endfor
{##}
## for attrib in msg/attributes
## if hasAnnotation(attrib, "IsSize")
{##}

            encoder.override(std::max<{{ attrib/type }}>(0, static_cast<{{ attrib/type }}>(encoder.size() - sizeof({{ attrib/type }}) - 1)), position_{{ attrib/name }});
## endif
## endfor
{##}
        }

        static {{ msg/name }} decode(keycap::root::network::memory_stream& decoder)
        {
            {{ msg/name }} packet;
## for attrib in msg/attributes
## if attrib/type == "string"
{##}
            auto size_{{ attrib/name }} = decoder.get<uint8>();
            packet.{{attrib/name}} = decoder.get_string(size_{{ attrib/name }});
## if attrib/hasAnnotations
## for annotation in attrib/annotations
## if annotation/name == "Expects"
{##}
            ensure("{{attrib/name}}", packet.{{attrib/name}}, "{{annotation/value}}");
## endif
## endfor
## endif
## else if attrib/hasSpecifier
## if hasSpecifier(attrib, "repeated")
{##}
            auto size_{{attrib/name}} = decoder.get<uint8>();
            for(int i = 0; i < size_{{attrib/name}}; ++i)
                packet.{{attrib/name}}.push_back(decoder.get<{{ attrib/type }}>());
## else if hasSpecifier(attrib, "optional")
{##}
            if(decoder.size() >= sizeof({{ attrib/type }}))
                packet.{{attrib/name}} = decoder.get<{{ attrib/type }}>();
## endif
## else if attrib/hasArraySize
{##}
            packet.{{attrib/name}} = decoder.get<{{ attrib/type }}, {{ attrib/arraySize }}>();
## else if not hasAnnotation(attrib, "IsSize")
{##}
            packet.{{attrib/name}} = decoder.get<{{ attrib/type }}>();
## endif
## if attrib/hasAnnotations
## for annotation in attrib/annotations
## if annotation/name == "Expects"
{##}
            ensure("{{attrib/name}}", packet.{{attrib/name}}, {{annotation/value}});

## else if annotation/name == "Reverse"
{##}
            std::reverse(std::begin(packet.{{attrib/name}}), std::end(packet.{{attrib/name}}));

## endif
## endfor
## endif
## endfor
{##}
            return packet;
        }

        std::string to_string()
        {
            std::stringstream ss;
            ss << "Packet {{ msg/name }}\n";
## for attrib in msg/attributes
## if attrib/hasSpecifier
## if attrib/specifier == "optional"
{##}

            if({{ attrib/name }})
            {
                ss << "    {{ attrib/name }}\n";
            }
            else
                ss << "    {{ attrib/name }} not set";
            ss << '\n';
## else
{##}

            ss << "    {{ attrib/name }}[" << {{ attrib/name }}.size() << "]\n";
            
            if constexpr(!std::is_class_v<{{ attrib/type }}>)
                keycap::root::utility::dump_as_hex(std::begin({{ attrib/name }}), std::end({{ attrib/name }}), ss, 8);
## endif
## else if attrib/hasArraySize
{##}

            ss << "    {{ attrib/name }}[{{ attrib/arraySize }}]\n";
            if constexpr(!std::is_class_v<{{ attrib/type }}>)
                keycap::root::utility::dump_as_hex(std::begin({{ attrib/name }}), std::end({{ attrib/name }}), ss, 8);
## else
{##}
            ss << "    {{ attrib/name }} = " << {{ attrib/name }} << '\n';
## endif
## endfor
{##}

            return ss.str();
        }

    private:
        template <typename T1, typename T2>
        static void ensure(std::string const& name, T1 const& v1, T2 const& v2)
        {
            if(v1 != v2)
                throw std::exception(fmt::format("Attribute '{}'({}) was expected to be {}", name, std::to_string(v1), std::to_string(v2)).c_str());
        }

        template <typename T>
        static void ensure(std::string const& name, std::vector<T> const& v1,  std::vector<T> const& v2)
        {
            
        }
    };

## endfor
## endif
{##}
#pragma pack(pop)
}