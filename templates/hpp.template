/*
    Copyright 2018 KeycapEmu

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

// This file was generated. DO NOT EDIT!

#pragma once

## if hasImports
## for imp in imports
{##}
#include <generated/{{ imp/importName }}.hpp>
## endfor
## endif
{##}

#include <keycap/root/network/memory_stream.hpp>
#include <keycap/root/types.hpp>
#include <keycap/root/utility/enum.hpp>
#include <keycap/root/utility/utility.hpp>

#include <boost/endian/conversion.hpp>
#include <boost/optional.hpp>

#include <spdlog/fmt/fmt.h>

namespace {% for i in modulePath %}{% if loop/is_first %}{{ i }}{% else %}::{{ i }}{% endif %}{% endfor %}
{
## if hasEnums
## for enum in enums
{##}
    keycap_enum{% if hasAnnotation(enum, "flags") %}_flags{% endif %}({{ enum/name }}, {% if enum/alignment == "byte" %}uint8{% else if enum/alignment == "word" %}uint16{% else if enum/alignment == "dword" %}uint32{% else if enum/alignment == "qword" %}uint64{% endif %},{%
for value in enum/values %}
        {{ value/name }} = {{ value/value }},{%
endfor %}
    );

## endfor
## endif
{##}
#pragma pack(push, 1)

## if hasData
## for dat in data
{##}
    struct {{ dat/name }}
    {
      public:{%
for attrib in dat/attributes %}
## include "hpp_helpers/dump_attributes.template"
{% endfor %}
## if hasAnnotation(dat, "expected_size")

        static constexpr size_t expected_size = {{annotationValue(dat, "expected_size")}};
## endif


        void encode(keycap::root::network::memory_stream& encoder)
        {
## for attrib in dat/attributes
## include "hpp_helpers/dump_encode.template"
## endfor
{##}
## for attrib in dat/attributes
## if hasAnnotation(attrib, "is_size")
{##}

{% include "hpp_helpers/dump_encode_issize.template" %}
## endif
## endfor
{##}
        }

        keycap::root::network::memory_stream encode()
        {
            keycap::root::network::memory_stream encoder;
## for attrib in dat/attributes
## include "hpp_helpers/dump_encode.template"
## endfor
{##}
## for attrib in dat/attributes
## if hasAnnotation(attrib, "is_size")
{##}

{% include "hpp_helpers/dump_encode_issize.template" %}
## endif
## endfor
{##}
            return encoder;
        }

        static {{ dat/name }} decode(keycap::root::network::memory_stream& decoder)
        {
            {{ dat/name }} packet;
## for attrib in dat/attributes
{% include "hpp_helpers/dump_decode.template" %}
## endfor
{##}
            return packet;
        }

      private:
{% include "hpp_helpers/dump_helpers.template" %}
    };

## endfor
## endif
## if hasMessages
{##}
## for msg in messages
{##}
    class {{ msg/name }} final
    {
      public:{%
for attrib in msg/attributes %}
## include "hpp_helpers/dump_attributes.template"
{% endfor %}

## if hasAnnotation(msg, "expected_size")

        static constexpr size_t expected_size = {{annotationValue(msg, "expected_size")}};

## endif

        void encode(keycap::root::network::memory_stream& encoder)
        {
## for attrib in msg/attributes
## include "hpp_helpers/dump_encode.template"
## endfor
{##}
## for attrib in msg/attributes
## if hasAnnotation(attrib, "is_size")
{##}

{% include "hpp_helpers/dump_encode_issize.template" %}
## endif
## endfor
{##}
        }

        keycap::root::network::memory_stream encode()
        {
            keycap::root::network::memory_stream encoder;
## for attrib in msg/attributes
## include "hpp_helpers/dump_encode.template"
## endfor
{##}
## for attrib in msg/attributes
## if hasAnnotation(attrib, "is_size")
{##}

{% include "hpp_helpers/dump_encode_issize.template" %}
## endif
## endfor
{##}
            return encoder;
        }

        static {{ msg/name }} decode(keycap::root::network::memory_stream& decoder)
        {
            {{ msg/name }} packet;
## for attrib in msg/attributes
{% include "hpp_helpers/dump_decode.template" %}
## endfor
{##}
            decoder.shrink();
            return packet;
        }

        std::string to_string()
        {
            std::stringstream ss;
            ss << "Packet {{ msg/name }}\n";
## for attrib in msg/attributes
## include "hpp_helpers/dump_to_string.template"
## endfor
{##}

            return ss.str();
        }

      private:
{% include "hpp_helpers/dump_helpers.template" %}
    };

## endfor
## endif
{##}
#pragma pack(pop)
}